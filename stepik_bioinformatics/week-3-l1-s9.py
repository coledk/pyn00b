def modify_list(l):
    i = 0
    while i < len(l):
        if l[i] % 2 == 0:
            l[i] = (int(l[i]) // 2)
            i += 1
        else:
            l.pop(i)

## Интересный вариант
## def modify_list(l):
##     l[:] = [i//2 for i in l if not i % 2]
## если второе то это обычный генератор списка с условием
## если первое то тут логика такая,
## так как список l в памяти уже есть и его нужно перезаписать,
## то есть изменить сам объект списка, поэтому тут я делаю срез
## всего списка от начала до конца и меняю сам объект.
## если написать просто l = [i//2 for i in l if not i % 2]
## в данном случае будет создан новый объект, под него выделена
## память и переменная l будет уже ссылаться на него,
## а старая ссылка на исходный объект списка сотрется.
## т.е происходит не изменение объекта, а перенаправление ссылки
## у переменной l. я не проверял может и такой вариант сработает
## но подумал что он учтет занимаемую память и выдаст ошибку,
## так как была задача одна и там подобный подход выдавал ошибку,
## а сделал l[:] (изменил сам весь объект) все заработало
